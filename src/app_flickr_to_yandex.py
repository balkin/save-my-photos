import logging
import os
from urllib.parse import urlparse
from xml.etree.ElementTree import Element

import flickrapi
import yadisk

logger = logging.getLogger(__name__)


class App:

    def __init__(self, flickr_key=None, flickr_secret=None,
                 yandex_id=None, yandex_secret=None, yandex_oauth=None) -> None:
        super().__init__()
        self.flickr = flickrapi.FlickrAPI(flickr_key, flickr_secret)
        self.yadisk = yadisk.YaDisk(yandex_id, yandex_secret, yandex_oauth)

    def run(self):
        self.flickr.authenticate_console()
        if self.flickr.token_valid():
            res = self.flickr.walk_photosets()
            for folder in res:
                self.process_folder(folder)

    def process_folder(self, folder: Element):
        flickr_photoset_title, flickr_photoset_id = folder.findtext('title'), folder.get('id')
        logger.debug(f"Folder #{flickr_photoset_id} {folder} = {flickr_photoset_title}")

        # In case you're using Yandex Services and you're not Russian, maybe it will have another name.
        camera_folder = os.environ.get("YANDEX_PHOTOCAMERA", "Фотокамера")
        yandex_folder = f"disk:/{camera_folder}/{flickr_photoset_title}"
        try:
            self.yadisk.get_meta(yandex_folder)
        except yadisk.exceptions.PathNotFoundError:
            self.yadisk.mkdir(yandex_folder)
        res = self.flickr.walk_set(flickr_photoset_id, 50, extras="url_o")
        for photo in res:
            self.process_photo(photo, yandex_folder)

    def process_photo(self, photo: Element, yandex_folder: str):
        """
        Process a single photo.

        Use Yandex feature to asynchronously load the photo from external URL.
        In case photo title is missing, a new name will be autogenerated from CDN path.

        Attributes of photo you may want to use if you're going to extend the app:

        - id (str) -- photo id in Flickr
        - url_o (str) -- Full CDN url of the image in original qualitys
        - title (str) -- Image title
        - ispublic (str) -- '0' or '1'
        - isfriend (str) -- '0' or '1'
        - isfamily (str) -- '0' or '1'
        - isprimary (str) -- '0' or '1'
        - secret (str)
        - server (str) -- probably flickr internal server id
        - farm (str)

        :param photo: Photo metadata.
        :param yandex_folder: Yandex Disk folder path
        :return:
        """
        id, url_o, title = photo.get('id'), photo.get('url_o'), photo.get('title')
        parsed = urlparse(url_o)
        path, ext = os.path.splitext(parsed.path)

        # If we do not know image title or filename, use the autogenreated name from Flickr CDN
        if title == '':
            title = path.replace('/', '')
            logger.warning(f"Image {id}: title was empty, new title is {title} (built from CDN path {url_o}")

        yandex_full_path = f"{yandex_folder}/{title}{ext}"
        try:
            # First, let's check whether the file already exists. We don't want to abuse Yandex or make clones
            self.yadisk.get_meta(yandex_full_path)
            logger.info(f"Skipping {yandex_full_path}, it's already there")
        except yadisk.exceptions.PathNotFoundError:
            try:
                # This method returns immediately, yandex disk will fetch the photo asynchronously
                self.yadisk.upload_url(url_o, yandex_full_path)
            except yadisk.exceptions.FieldValidationError as e:
                logger.exception(f"Something went wrong when trying to upload {url_o} to {yandex_full_path}", e)


if __name__ == '__main__':
    app = App('24e321effac5a2bab1d495941800e2fe', 'a83ab8f70a937508',
              '5bfb4e55ee8d420782c01a7f9c513eaa', '7012d30f061640da8b0e68fa91a2dc60',
              yandex_oauth=os.environ.get('YANDEX_OAUTH'))
    app.run()
